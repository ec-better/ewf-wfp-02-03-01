#!/opt/anaconda/envs/env_ewf_wfp_02_03_01/bin/python

import os
import sys

sys.path.append('/'.join([os.environ['_CIOP_APPLICATION_PATH'], 'util']))
sys.path.append('../util')

from s2_whittaker_helpers import *

import string
import atexit
import pandas as pd
import cioppy
import datetime
ciop = cioppy.Cioppy()
    
# define the exit codes
SUCCESS = 0
ERR_RESOLUTION = 10
ERR_STAGEIN = 20
ERR_NO_OUTPUT = 30

# add a trap to exit gracefully
def clean_exit(exit_code):
    log_level = 'INFO'
    if exit_code != SUCCESS:
        log_level = 'ERROR'  

    msg = {SUCCESS: 'Processing successfully concluded',
           ERR_RESOLUTION: 'Could not resolve Sentinel-2 product enclosure',
           ERR_STAGEIN: 'Could not stage-in Sentinel-2 product', 
           ERR_NO_OUTPUT: "Missing output"
    }
 
    ciop.log(log_level, msg[exit_code])  

def main():
        
    ciop = cioppy.Cioppy()
    
    os.chdir(ciop.tmp_dir)
    
    band_to_process = ciop.getparam('band')

    data_pipeline_parameters = dict()    
    
    data_pipeline_parameters['username'] = ciop.getparam('_T2Username')
    data_pipeline_parameters['api_key'] = ciop.getparam('_T2ApiKey')
    creds = '{}:{}'.format(data_pipeline_parameters['username'],
                           data_pipeline_parameters['api_key'])

    for input in sys.stdin:
        
        #output_name = os.path.join(ciop.tmp_dir, input.rstrip().split(',')[0])

        ciop.log('INFO', 'Processing tile {}'.format(input.rstrip()))
        
        local_subtile = ciop.copy(input.rstrip(),
                                  ciop.tmp_dir,
                                  extract=False)
        
        ciop.log('INFO', 'Processing local tile {}'.format(local_subtile))

        sub_tile = pd.read_pickle(local_subtile, 'gzip')
        
        ciop.log('INFO', 'Getting the arrays for local tile {}'.format(local_subtile))

        sub_tile = sub_tile.merge(sub_tile.apply(lambda row: analyse_subtile(row, data_pipeline_parameters, band_to_process), axis=1),
                                  left_index=True,
                                  right_index=True)

        if sub_tile.duplicated(['day']).any():
    
            duplicated_day = sub_tile[sub_tile.duplicated(['day'])].day.values[0]
            duplicates = sub_tile[sub_tile.day == duplicated_day]

            for index, row in duplicates.iterrows():

                if np.isnan(duplicates[band_to_process][index][0]).all():
                
                    sub_tile  = sub_tile.drop([index])
        
        ciop.log('INFO', 'Smoothing local tile {}'.format(local_subtile))
        dates = sub_tile['jday']
        
        # the generate_dates function creates a list of days with a delta time=5
        full_dates = generate_dates(startdate_string=list(dates)[0], enddate_string=list(dates)[-1], delta=5)
        
        # the date_mask array is False when there is no product associated to that date.
        # this is needed by the whittaker function in the interpolation step.
        date_mask = np.array([True if x in list(dates) else False for x in full_dates])

        data_stack = np.stack(sub_tile[band_to_process])
        result = np.apply_along_axis(whittaker, 0, data_stack, date_mask)

        ### Creating s GeoTiff ###
        ciop.log('INFO', 'Create the s GeoTIFF product for local tile {}'.format(local_subtile))
        geo_transform = sub_tile['geo_transform'].values[0][0]
        projection = sub_tile.projection.unique()[0]
        band_number = 1
        cols = result.shape[1]
        rows = result.shape[2]

        print ('s', band_number, cols, rows)

        drv = gdal.GetDriverByName('GTiff')

        ds = drv.Create('s_{}_{}.tif'.format(band_to_process, os.path.basename(local_subtile)), 
                        cols, rows, 
                        band_number, 
                        gdal.GDT_Float32)

        ds.SetGeoTransform(geo_transform)
        ds.SetProjection(projection)
        ds.GetRasterBand(1).WriteArray(result[0], 0, 0)
        ds.FlushCache()
        
        ### Creating original values GeoTiff ###
        ciop.log('INFO', 'Create the original {} GeoTIFF product for local tile {}'.format(band_to_process, local_subtile))
        band_number = data_stack.shape[0]
        cols = data_stack.shape[1]
        rows = data_stack.shape[2]

        ciop.log('DEBUG', ' '.join(['original values', str(band_number), str(cols), str(rows)]))

        drv = gdal.GetDriverByName('GTiff')

        ds = drv.Create('original_{}_{}.tif'.format(band_to_process, os.path.basename(local_subtile)),
                        cols, rows, 
                        band_number, 
                        gdal.GDT_Float32)

        ds.SetGeoTransform(geo_transform)
        ds.SetProjection(projection)
        ds.FlushCache()
        
        ds = gdal.Open('original_{}_{}.tif'.format(band_to_process, os.path.basename(local_subtile)), gdal.OF_UPDATE)

        for index, band in enumerate(range(0, band_number)):
        
            product_date = datetime.datetime.strptime(dates[index], '%Y%j').date()
            date = '{}{:02d}{:02d}'.format(product_date.year, product_date.month, product_date.day)
            
            metadata = dict()
            metadata['date'] = date

            ds.GetRasterBand(index + 1).WriteArray(data_stack[index], 0, 0)
            ds.GetRasterBand(index + 1).SetDescription(dates[index])
            ds.GetRasterBand(index + 1).SetMetadata(metadata)

        ds.FlushCache()
        
        ### Creating GeoTiff ###
        ciop.log('INFO', 'Create the {} GeoTIFF product for local tile {}'.format(band_to_process, local_subtile))
        band_number = result.shape[0] - 1
        cols = result.shape[1]
        rows = result.shape[2]

        ciop.log('DEBUG', ' '.join([str(band), str(band_number), str(cols), str(rows)]))

        drv = gdal.GetDriverByName('GTiff')

        ds = drv.Create('{}_{}.tif'.format(band_to_process, os.path.basename(local_subtile)), 
                        cols, rows, 
                        band_number, 
                        gdal.GDT_Float32)

        ds.SetGeoTransform(geo_transform)
        ds.SetProjection(projection)
        ds.FlushCache()
        
        ds = gdal.Open('{}_{}.tif'.format(band_to_process, os.path.basename(local_subtile)), gdal.OF_UPDATE)

        for index, band in enumerate(range(0, band_number)):
        
            product_date = datetime.datetime.strptime(full_dates[index], '%Y%j').date()
            date = '{}{:02d}{:02d}'.format(product_date.year, product_date.month, product_date.day)
            band_is_interpolated = 'False' if full_dates[index] in list(dates) else 'True'

            metadata = dict()
            metadata['date'] = date
            metadata['band_is_interpolated'] = band_is_interpolated

            ds.GetRasterBand(index + 1).WriteArray(result[index + 1], 0, 0)
            ds.GetRasterBand(index + 1).SetDescription(full_dates[index])
            ds.GetRasterBand(index + 1).SetMetadata(metadata)

        ds.FlushCache()
        
        for result in ['s_{}_{}.tif'.format(band_to_process, os.path.basename(local_subtile)),
                       '{}_{}.tif'.format(band_to_process, os.path.basename(local_subtile)),
                       'original_{}_{}.tif'.format(band_to_process, os.path.basename(local_subtile))]:
        
            ciop.log('INFO', 'Publish {}'.format(result))
            ciop.publish(os.path.join(ciop.tmp_dir, result))

try:
    main()
except SystemExit as e:
    if e.args[0]:
        clean_exit(e.args[0])
    raise
else:
    atexit.register(clean_exit, 0)
